#ifndef MLIR_QUANTUM_DIALECT_H
#define MLIR_QUANTUM_DIALECT_H

#include "mlir/IR/Dialect.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/StandardTypes.h"
#include "mlir/IR/FunctionSupport.h"
#include "mlir/Interfaces/SideEffectInterfaces.h"
#include "mlir/Interfaces/CallInterfaces.h"

namespace mlir {
namespace OpTrait {
template <typename ConcreteType>
class UnitaryTrait : public OpTrait::TraitBase<ConcreteType, UnitaryTrait> {};

template <typename ConcreteType>
class HermitianTrait : public OpTrait::TraitBase<ConcreteType, HermitianTrait> {};

template <typename ConcreteType>
class MetaOpTrait : public OpTrait::TraitBase<ConcreteType, MetaOpTrait> {};
} // namespace OpTrait

namespace quantum {
namespace detail {

struct QuregTypeStorage;
struct COpTypeStorage;

} // end namespace detail

// This class represents individual qubits. It derives from mlir::detail::StorageUserBase
// (aliased to mlir::Type::TypeBase) as all custom types must. The template parameters
// consist of the concrete type (QubitType), and the base class to use (Type).
class QubitType : public Type::TypeBase<QubitType, mlir::Type, mlir::TypeStorage> {
public:
    // 'Base' is a type alias for the templated mlir::detail::StorageUserBase class,
    // just as TypeBase is (but inside mlir::detail::StorageUserBase instead of mlir::Type).
    // Thus we expose the contructors from 'TypeBase' here.
    using Base::Base;

    // This is used to get an instance of the 'QubitType'. Given that this is
    // a parameterless type, it just needs the context for uniquing purposes.
    static QubitType get(mlir::MLIRContext *ctx) { return Base::get(ctx); }
};

// This class represents a register of qubits, with a minimum of one qubit. For such a
// parametrized type, we also need to the type with a custom storage class (QuregTypeStorage).
class QuregType : public Type::TypeBase<QuregType, Type, detail::QuregTypeStorage> {
public:
    using Base::Base;

    // This method is a bit different from the simple type above. It takes the parameters
    // required for uniquing which will be passed to the container (storage) class.
    // It will also assert that all of the construction invariants are satisfied by
    // calling 'verifyContructionInvariants'. To gracefully handle errors, use getChecked.
    static QuregType get(mlir::MLIRContext *ctx, llvm::Optional<int> size);

    // Return the register size
    llvm::Optional<int> getNumQubits();
};

// This class represents a native quantum gate on one qubit.
class U1Type : public Type::TypeBase<U1Type, mlir::Type, mlir::TypeStorage> {
public:
    using Base::Base;

    static U1Type get(mlir::MLIRContext *ctx) {
        return Base::get(ctx);
    }
};

// This class represents a native quantum gate on two qubits.
class U2Type : public Type::TypeBase<U2Type, mlir::Type, mlir::TypeStorage> {
public:
    using Base::Base;

    static U2Type get(mlir::MLIRContext *ctx) {
        return Base::get(ctx);
    }
};

// This class represents controlled operations, where the underlying operation
// could be a single op or an entire circuit.
class COpType : public Type::TypeBase<COpType, mlir::Type, detail::COpTypeStorage> {
public:
    using Base::Base;

    static COpType get(mlir::MLIRContext *ctx, llvm::Optional<int> nctrl, Type baseType);

    llvm::Optional<int> getNumCtrls();

    Type getBaseType();
};

// This class represents a quantum circuit, that is, a collection of quantum ops.
class CircType : public Type::TypeBase<CircType, mlir::Type, mlir::TypeStorage> {
public:
    using Base::Base;

    static CircType get(mlir::MLIRContext *ctx) {
        return Base::get(ctx);
    }
};
} // namespace quantum
} // namespace mlir


// Add autogenerated header files from the ODS system, which include operation declarations
#define GET_DIALECT_CLASSES
#include "QuantumOpsDialect.h.inc"
#define GET_INTERFACE_CLASSES
#include "QuantumInterfaces.h.inc"
#define GET_OP_CLASSES
#include "QuantumOps.h.inc"

#endif // MLIR_QUANTUM_DIALECT_H
