#ifndef MLIR_QUANT_DIALECT_H
#define MLIR_QUANT_DIALECT_H

#include "mlir/IR/Dialect.h"

namespace mlir {
namespace quant {  // c++ namespace != mlir namespace (q.)

// Need to define the QuantDialect class here for further use (not generated via ODS).
// The contructor will be defined later which will register all custom types, attributes, etc.
class QuantDialect : public mlir::Dialect {
public:
  explicit QuantDialect(mlir::MLIRContext *ctx);

  /// A hook used to materialize constant values with the given type.
  //Operation *materializeConstant(OpBuilder &builder, Attribute value, Type type, Location loc) override;

  // Parse an instance of a type registered to the toy dialect.
  mlir::Type parseType(mlir::DialectAsmParser &parser) const override;

  // Print an instance of a type registered to the toy dialect.
  void printType(mlir::Type type, mlir::DialectAsmPrinter &printer) const override;

  // Provide a utility accessor to the dialect namespace. This is used by
  // several utilities for casting between dialects.
  static llvm::StringRef getDialectNamespace() { return "q"; }
};

// Add autogenerated header files from the ODS system, which include operation declarations
#define GET_OP_CLASSES
#include "QuantOps.h.inc"

// if required, declare storage class for parametric custom types
namespace detail {
struct QuregTypeStorage;
}

// MLIR types are represented by a *unique* value (for efficiency), which means all types must be
// statically assigned a value by entering them in a global registry (DialectSymbolRegistry.def).
// We can use PRIVATE_EXPERIMENTAL_0 (to 9) reserved for prototyping (each with a range of 256).
namespace QuantTypes {
enum Kinds {
    Qubit = mlir::Type::Kind::FIRST_PRIVATE_EXPERIMENTAL_0_TYPE,
    Qureg
};
}

} // namespace quant
} // namespace mlir

#endif // MLIR_QUANT_DIALECT_H
